// COMBINE METHODS
import { combineLatest, combineLatestWith, forkJoin, merge, of, pairwise, startWith, take, timer, zip } from "rxjs";
import { concatWith } from "rxjs/operators";


// 1. ====  combineLatestWith ==== 
const timer1$ = timer(1000, 4000)
    .pipe(
        take(3)
    );

const timer2$ = timer(2000,4000)
    .pipe(
        take(3)
    );
const timer3$ = timer(3000,4000)
    .pipe(
        take(3)
    );


// timer1$.subscribe( (v ) =>  console.log('v1=', v))
// timer2$.subscribe( (v ) =>  console.log('v2=', v))
// timer3$.subscribe( (v ) =>  console.log('v3=', v))

// Каждый раз, когда хотя бы одно из исходных наблюдаемых испускает новое значение, новая последовательность испускает массив, содержащий последние значения из всех наблюдаемых.
const o1$ = timer1$.pipe(
    combineLatestWith(timer2$, timer3$)
)

// 0-1-2-3-4-5-6-7-8-9-10
// 0-------1-------2|
// ----0-----1-------2|
// ------0-----1-------2|

// [0, 0, 0]
// [1, 0, 0]
// [1, 1, 0]
// [1, 1, 1]
// [2, 1, 1]
// [2, 2, 1]
// [2, 2, 2]


// 2. ==== zip ==== 
//  для объединения значений из нескольких наблюдаемых последовательностей в одну новую последовательность. 
//  При этом значения из разных последовательностей объединяются в пары (или кортежи, если последовательностей больше двух) по порядку их испускания.
const o2$ = zip(timer1$, timer2$, timer3$);

// [0, 0, 0]
// [1, 1, 1]



// 3. ==== forkJoin ====
// используется для объединения результатов нескольких наблюдаемых последовательностей в одну новую последовательность. Он ждет, пока все наблюдаемые завершат свою работу, и только после этого испускает массив последних значений, которые они выдали.
const o3$ = forkJoin([timer1$, timer2$, timer3$]);
// [2, 2, 2]



const t1$ = timer(0, 1000).pipe(take(3));
const t2$ = timer(0, 100).pipe(take(3));
const secondSource$ = of('a', 'b', 'c');

// 4. ==== concatWith ==== 
// Последовательное объединение
// при этом значения из одного потока должны идти после значений из предыдущего.
const o4$ = t1$.pipe(
    concatWith(secondSource$)
)
// 0
// 1
// 2
// a
// b
// c



// 5. ==== merge ==== 
// используется для объединения нескольких наблюдаемых последовательностей (Observables) в одну. 
// Он принимает на вход несколько наблюдаемых и испускает значения из каждого из них по мере их поступления, не ожидая завершения предыдущего.
const o5$ = merge(t1$, t2$);



// 6. ==== startWith ==== 
const o6$ =t1$.pipe(
    startWith('5')
)


// 7. ==== pairwise ==== 
// предназначен для сравнения текущего и предыдущего значений, испускаемых наблюдаемой последовательностью. 
// Он объединяет эти два значения в массив и испускает этот массив как новое значение.
//
// Как это работает:
//   Первое значение: Для первого значения, испускаемого исходной наблюдаемой, pairwise ничего не испускает, так как нет предыдущего значения для сравнения.
//   Последующие значения: Для каждого последующего значения pairwise создает массив, состоящий из предыдущего и текущего значения, и испускает этот массив.
    
    
const t3$ = timer(0, 1000).pipe(take(7));
const o7$ =t3$.pipe(
    pairwise()
)

// [0, 1]
// [1, 2]
// [2, 3]
// [3, 4]
// [4, 5]
// [5, 6]


o7$.subscribe({  
    next: (value:any) => console.log(value),
    complete: () => console.log('Complete!'),
    error: (error) => console.log('Error', error),
})








// const num$ = of(1,2,3,4,5);
// const alp$ = of('a', 'b', 'c', 'd' , 'e');
//
// const union$ = zip(num$, alp$).pipe().subscribe( (v) => console.log(v))